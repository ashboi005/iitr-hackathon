Here's a structured **step-by-step guide** based on the steps you provided, ensuring smooth integration of Clerk authentication in your **Next.js** app with webhooks.

---

# **Clerk Authentication with Next.js - Step-by-Step Guide**
This guide walks you through integrating **Clerk authentication** into your Next.js app, including **setting up authentication routes, configuring middleware, and syncing data using webhooks**.

---

## **Step 1: Install Clerk SDK**
First, install the **Clerk SDK** in your Next.js project:

```sh
npm install @clerk/nextjs
```

This will add Clerk's authentication capabilities to your app.

---

## **Step 2: Set Clerk API Keys**
Create or update your `.env` file in the root of your project and add the following Clerk API keys:

```env
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=your_publishable_key
CLERK_SECRET_KEY=your_secret_key
```

You can find these keys in your **Clerk Dashboard > API Keys**.

---

## **Step 3: Configure Clerk Middleware**
Update or create a `middleware.ts` file in the root of your project (`/src/` if using a structured directory).

Add the following code to enable authentication:

```ts
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";

// Define public routes that do not require authentication
const isPublicRoute = createRouteMatcher([
  "/sign-in(.*)",
  "/sign-up(.*)",
  "/api/webhooks(.*)", // Webhook endpoint must be public
]);

export default clerkMiddleware(async (auth, req) => {
  if (!isPublicRoute(req)) {
    await auth.protect(); // Protects all non-public routes
  }
});

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    "/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)",
    // Always run for API routes
    "/(api|trpc)(.*)",
  ],
};
```

This middleware:
- Protects private routes.
- Allows public access to **sign-in**, **sign-up**, and **webhook** routes.

---

## **Step 4: Add Clerk Provider to Your App**
Wrap your app in `ClerkProvider` to enable authentication across your application.

### **For App Router (`app/layout.tsx`)**
```tsx
import { ClerkProvider } from "@clerk/nextjs";

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return <ClerkProvider>{children}</ClerkProvider>;
}
```

---

## **Step 5: Build Authentication Pages**
Clerk provides built-in authentication components like **SignIn** and **SignUp**.

### **Sign-in Page (`app/sign-in/[[...sign-in]]/page.tsx`)**
```tsx
import { SignIn } from "@clerk/nextjs";

export default function Page() {
  return <SignIn />;
}
```

### **Sign-up Page (`app/sign-up/[[...sign-up]]/page.tsx`)**
```tsx
import { SignUp } from "@clerk/nextjs";

export default function Page() {
  return <SignUp />;
}
```

### **Update Environment Variables**
Add the following to your `.env` file:

```env
NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
NEXT_PUBLIC_CLERK_SIGN_IN_FALLBACK_REDIRECT_URL=/
NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
NEXT_PUBLIC_CLERK_SIGN_UP_FALLBACK_REDIRECT_URL=/
```

These variables define where users are redirected after signing in or signing up.

---

## **Step 6: Sync Clerk Data Using Webhooks**
To keep your app **in sync** with Clerkâ€™s user data, set up **webhooks**.

---

### **Step 6.1: Install `svix`**
Clerk uses **Svix** for webhook delivery. Install it with:

```sh
npm install svix
```

---

### **Step 6.2: Set Up ngrok**
To test webhooks locally, you need to expose your local server to the internet using **ngrok**.

1. **Create an ngrok account** and install ngrok.
2. **Run ngrok** (replace `3000` with your local port):
   ```sh
   ngrok http 3000
   ```
3. Copy the **Forwarding URL** generated by ngrok.

---

### **Step 6.3: Create Webhook in Clerk Dashboard**
1. Go to **Clerk Dashboard > Webhooks**.
2. Click **Add Endpoint**.
3. Paste your **ngrok forwarding URL** followed by `/api/webhooks`:
   ```
   https://nationally-concrete-hermit.ngrok-free.app/api/webhooks
   ```
4. Select **user.created** event.
5. Click **Create**.
6. Copy the **Signing Secret** and add it to `.env`:

```env
SIGNING_SECRET=your_webhook_signing_secret
```

---

### **Step 6.4: Create Webhook Route in Next.js**
Create a **webhook handler** in `app/api/webhooks/route.ts`:

```ts
import { Webhook } from "svix";
import { headers } from "next/headers";
import { WebhookEvent } from "@clerk/nextjs/server";

export async function POST(req: Request) {
  const SIGNING_SECRET = process.env.SIGNING_SECRET;

  if (!SIGNING_SECRET) {
    throw new Error("Error: Please add SIGNING_SECRET from Clerk Dashboard to .env");
  }

  // Create new Svix instance
  const wh = new Webhook(SIGNING_SECRET);

  // Get headers
  const headerPayload = await headers();
  const svix_id = headerPayload.get("svix-id");
  const svix_timestamp = headerPayload.get("svix-timestamp");
  const svix_signature = headerPayload.get("svix-signature");

  // If headers are missing, reject the request
  if (!svix_id || !svix_timestamp || !svix_signature) {
    return new Response("Error: Missing Svix headers", { status: 400 });
  }

  // Get request body
  const payload = await req.json();
  const body = JSON.stringify(payload);

  let evt: WebhookEvent;

  try {
    evt = wh.verify(body, {
      "svix-id": svix_id,
      "svix-timestamp": svix_timestamp,
      "svix-signature": svix_signature,
    }) as WebhookEvent;
  } catch (err) {
    console.error("Error: Could not verify webhook:", err);
    return new Response("Error: Verification error", { status: 400 });
  }

  // Process webhook event
  const { id } = evt.data;
  const eventType = evt.type;

  console.log(`Received webhook with ID ${id} and event type: ${eventType}`);
  console.log("Webhook payload:", body);

  if (evt.type === "user.created") {
    console.log("User ID:", evt.data.id);
  }

  return new Response("Webhook received", { status: 200 });
}
```

---

## **Step 7: Test the Webhook**
1. Start your Next.js app:
   ```sh
   npm run dev
   ```
2. Go to **Clerk Dashboard > Webhooks > Testing**.
3. Select **user.created** event and click **Send Example**.
4. Check your **terminal logs** to see the received webhook payload.

---

## **Step 8: Deploy to Production**
### **Step 8.1: Create a Production Webhook**
1. In **Clerk Dashboard**, add a new webhook.
2. Use your **production URL** instead of the **ngrok URL**.
3. Copy the new **Signing Secret**.
4. Update your **production environment variables** (`SIGNING_SECRET`).
5. Redeploy your app.



## **Conclusion**
âœ… **Clerk authentication** is now integrated into your Next.js app.  
âœ… You have a **sign-in** and **sign-up** page.  
âœ… Webhooks are **set up** to sync user data.  

This setup ensures **seamless authentication** and **automatic data syncing** between Clerk and your app. ðŸš€

### Step 1: **Set up Prisma in Your Next.js App**

1. **Install Prisma**
   
   First, you'll need to install Prisma CLI and Prisma Client. Run the following command:

   ```bash
   npm install @prisma/client prisma
   ```

2. **Initialize Prisma**

   Now, initialize Prisma in your project:

   ```bash
   npx prisma init
   ```

   This command creates a `prisma` folder with a `schema.prisma` file and a `.env` file. You will configure your database connection in these files.

### Step 2: **Set Up Your Database (SQLite in This Case)**

1. **Configure SQLite Database**

   In your `.env` file, set up the SQLite database connection:

   ```env
   DATABASE_URL="file:./dev.db"  // SQLite database will be saved in your project root
   ```

2. **Modify `schema.prisma`**

   Open the `prisma/schema.prisma` file and define a `User` model that will store the user data you want to save from the webhook:

   ```prisma
   datasource db {
     provider = "sqlite"
     url      = env("DATABASE_URL")
   }

   generator client {
     provider = "prisma-client-js"
   }

   model User {
     id        String   @id @default(cuid())
     email     String   @unique
     firstName String
     lastName  String
     createdAt DateTime @default(now())
   }
   ```

   Here, weâ€™re creating a `User` table with fields like `id`, `email`, `firstName`, `lastName`, and `createdAt`.

### Step 3: **Run Prisma Migrations**

1. **Create the Database**

   Now, create the SQLite database and apply the schema by running:

   ```bash
   npx prisma migrate dev --name init
   ```

   This command creates the SQLite database file (`dev.db`) and applies the migrations based on your `schema.prisma`.

2. **Generate Prisma Client**

   After setting up the schema, generate the Prisma Client to interact with your database:

   ```bash
   npx prisma generate
   ```

### Step 4: **Integrate Prisma with Your Webhook Handler**

1. **Import Prisma Client**

   In your `app/api/webhooks/route.ts` file, import Prisma Client and initialize it:

   ```ts
   import { PrismaClient } from '@prisma/client'
   const prisma = new PrismaClient()
   ```

2. **Save Data to Database**

   Now that you have Prisma set up, you can insert the user data from the webhook into your database. Modify your existing webhook handler to insert the data into your `User` table:

   ```ts
   import { Webhook } from 'svix'
   import { WebhookEvent } from '@clerk/nextjs/server'
   import { PrismaClient } from '@prisma/client'

   const prisma = new PrismaClient()

   export async function POST(req: Request) {
     const SIGNING_SECRET = process.env.SIGNING_SECRET

     if (!SIGNING_SECRET) {
       return new Response('SIGNING_SECRET is missing', { status: 500 })
     }

     const wh = new Webhook(SIGNING_SECRET)

     const { 'svix-id': svixId, 'svix-timestamp': svixTimestamp, 'svix-signature': svixSignature } = req.headers

     if (!svixId || !svixTimestamp || !svixSignature) {
       return new Response('Missing Svix headers', { status: 400 })
     }

     const payload = await req.json()
     const body = JSON.stringify(payload)

     let evt: WebhookEvent

     try {
       evt = wh.verify(body, {
         'svix-id': svixId,
         'svix-timestamp': svixTimestamp,
         'svix-signature': svixSignature,
       }) as WebhookEvent
     } catch (err) {
       console.error('Error verifying webhook:', err)
       return new Response('Verification error', { status: 400 })
     }

     const { id, email, first_name, last_name } = evt.data

     // Insert data into the database
     try {
       const user = await prisma.user.create({
         data: {
           id,
           email,
           firstName: first_name,
           lastName: last_name,
         },
       })

       console.log('User successfully saved:', user)
     } catch (error) {
       console.error('Error saving user:', error)
       return new Response('Error saving user', { status: 500 })
     }

     return new Response('Webhook received', { status: 200 })
   }
   ```

### Explanation of the Code:
1. **Webhook Verification**: First, you verify the webhook payload using the **Svix** library, which ensures the data is valid and secure.
   
2. **Extract User Data**: You extract the necessary user data (like `id`, `email`, `first_name`, `last_name`) from the event data provided by Clerk.

3. **Insert into Database**: Using Prismaâ€™s `prisma.user.create()` method, you insert the extracted user data into the `User` table in your SQLite database.

4. **Handle Errors**: Any errors while saving the user to the database are caught and logged.

### Step 5: **Test Your Integration**

1. **Test Webhook**: Trigger a **user.created** event via the Clerk Dashboard or your app. Ensure that the user data is logged to the console and saved in your database.
   
2. **Check Your Database**: After the webhook event is triggered, check your SQLite database (`dev.db`). You can use Prisma Studio for an easy-to-use interface to view the data:

   ```bash
   npx prisma studio
   ```

### Step 6: **Deploying to Production**

1. **Change Database Connection**: If youâ€™re moving to production, update the `DATABASE_URL` in your `.env` file to point to your production database (e.g., PostgreSQL).

2. **Deploy to Vercel**: When deploying to Vercel, make sure to add your environment variables (e.g., `SIGNING_SECRET`, `DATABASE_URL`) in the Vercel dashboard under **Environment Variables**.

### Conclusion:

Now youâ€™ve integrated the Clerk webhook with your Next.js app and Prisma, storing the incoming data into your SQLite database. This process can be easily adapted for other databases, such as PostgreSQL or MySQL, by simply updating your `DATABASE_URL` and Prisma schema. 
